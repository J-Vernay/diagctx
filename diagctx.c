/*
This is the C implementation of the diagctx library, written by Julien Vernay ( jvernay.fr ) in 2021.
diagctx is a library to log context (= arbitrary data) and retrieve it in case of errors.
The library is available under the Boost Software License 1.0, whose terms are below:

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

#include "diagctx.h"

#if __STDC_VERSION__ >= 201112L && !__STDC_NO_THREADS__
#    define THREAD_LOCAL _Thread_local
#elif __STDCPP_THREADS__
#    define THREAD_LOCAL thread_local
#else
#    define THREAD_LOCAL
#endif

#include <assert.h>
#define NULL ((void*) 0)

struct diagctx_infos {
    char* buffer;
    unsigned capacity;
    unsigned message_size;
    unsigned current_id;
    void(*msg_destructor)(void*);
};

static THREAD_LOCAL struct diagctx_infos diagctx = {0};


void diagctx_init(unsigned message_size,
                  void* buffer,
                  unsigned capacity,
                  void(*msg_destructor)(void*))
{
    assert(buffer != NULL && "[diagctx] buffer == NULL in initialization");
    diagctx.message_size = message_size;
    diagctx.msg_destructor = msg_destructor;
    diagctx.current_id = 0;
    diagctx.capacity = capacity;
    
    diagctx.buffer = (char*)buffer;
}

void* diagctx_push(unsigned* msg_id) {
    unsigned id = diagctx.current_id++;
    *msg_id = diagctx.current_id;
    if (id < diagctx.capacity)
        return diagctx.buffer + diagctx.message_size * id;
    else
        return NULL;
}

void diagctx_pop(unsigned msg_id) {
    assert(diagctx.current_id == msg_id && "[diagctx] mismatch in diagctx_pop(), an intermediate diagctx_pop() have been missed.");
    unsigned id = --diagctx.current_id;
    if (diagctx.msg_destructor != NULL && id < diagctx.capacity)
        (*diagctx.msg_destructor)(diagctx.buffer + diagctx.message_size * id);
}

void diagctx_get(unsigned msg_id, diagctx_handler_t* handler, void* userdata) {
    assert((msg_id == (unsigned)-1 || msg_id <= diagctx.current_id) && "[diagctx] incoherent msg_id in diagctx_get...");
    
    /* These are copied locally to ensure that thread_local access are done only once. */
    unsigned capacity = diagctx.capacity;
    unsigned message_size = diagctx.message_size;
    char* buffer = diagctx.buffer;
    void(*msg_destructor)(void*) = diagctx.msg_destructor;
    
    unsigned i = 0, imax = diagctx.current_id;
    for (; i < imax; ++i) {
        void* msg_ptr = (i >= capacity) ? NULL : buffer + message_size * i;
        if (handler)
            (*handler)(userdata, msg_ptr); 
        if (msg_destructor != NULL && i >= msg_id && msg_ptr != NULL)
            (*msg_destructor)(msg_ptr);
    }
    if (msg_id != (unsigned)-1)
        diagctx.current_id = msg_id;
}



